/*Jerome Hayes JrHW32/19/2016This program is my homework 3 assignment. There is 4 different algorithms and thereis test code to show the proper function of them.100% completed*/#include <list>#include <iostream>using namespace std;template <class T>list<T> ordered_union(const list<T> &a, const list<T> &b){    typename list<T>::const_iterator Itera,Iterb,enda,endb;    list<T> temp;        Itera = a.begin();    Iterb = b.begin();    enda = a.end();    endb = b.end();    if (a.empty())        return b;    if (b.empty())        return a;    while (Itera != enda && Iterb != endb) {        if ((*Itera) < (*Iterb)) {           temp.push_back(*Itera);           Itera++;        } else if ((*Itera) > (*Iterb)) {           temp.push_back(*Iterb);           Iterb++;        } else {            temp.push_back(*Itera);            Itera++;            Iterb++;        } if(Iterb == endb){            temp.push_back(*Itera);            Itera++;        } else if (Itera == enda) {            temp.push_back(*Iterb);            Iterb++;        }    }    return temp;}//ordered_uniontemplate<class T>list<T> ordered_intersect(const list<T> &a, const list<T> &b){    typename list<T>::const_iterator Itera,Iterb;    list<T> temp;    Itera = a.begin();    Iterb = b.begin();    while (Itera != a.end() && Iterb != b.end()) {        if ((*Itera) == (*Iterb)) {            temp.push_back(*Iterb);            Itera++;            Iterb++;        }        else if ((*Itera) > (*Iterb))            Iterb++;        else if ((*Iterb) > (*Itera))            Itera++;          }    return temp;}//ordered_intersecttemplate<class T>list<T> unordered_union(const list<T> &a, const list<T> &b){    list<T> tempa = a;    list<T> tempb = b;    list<T> temp;    if (a.empty())        return b;    if (b.empty())        return a;    tempa.sort();    tempb.sort();    temp = ordered_union(tempa,tempb);    return temp;}//unordered_uniontemplate<class T>list<T> unordered_intersection(const list<T> &a, const list<T> &b){    list<T> tempa = a;    list<T> tempb = b;    list<T> temp;    tempa.sort();    tempb.sort();    temp = ordered_intersect(tempa,tempb);    return temp;}//unordered_intersectiontemplate<class T>void printList(const list<T> &a){    typename list<T>::const_iterator citer;    citer = a.begin();    while(citer != a.end()){        cout << *citer << " ";        citer++;    }    cout << endl << endl;}// printListint main(){    list<int> l,m,t,z;    l.push_back(1);    l.push_back(27);    l.push_back(28);    l.push_back(16);    l.push_back(54);    l.push_back(72);    l.sort();    m.push_back(15);    m.push_back(1);    m.push_back(5);    m.push_back(23);    m.push_back(9);    m.push_back(89);    m.sort();    cout<< "first list:" << endl;    printList(l);    cout<< "Second list:" << endl;    printList(m);    t = ordered_union(l,m);    z = ordered_intersect(l,m);    cout << "Ordered Union: " << endl;    printList(t);    cout << "Ordered intersect: " << endl;    printList(z);    list<int> a,b,c,d;    a.push_back(54);    a.push_back(7);    a.push_back(3);    a.push_back(92);    a.push_back(43);    a.push_back(2);    a.push_back(5);    cout << "Third list: " << endl;    printList(a);    b.push_back(88);    b.push_back(1);    b.push_back(7);    b.push_back(77);    b.push_back(2);    b.push_back(43);    b.push_back(12);    b.push_back(37);    cout << "Fourth list: " << endl;    printList(b);    c = unordered_union(a,b);    d = unordered_intersection(a,b);    cout << "Unordered union:" << endl;    printList(c);    cout << "Unordered intersect:" << endl;    printList(d);    return 0;}//main