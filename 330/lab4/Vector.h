/*****************************************************************************Jerome Hayes JrVector.h2/3/16This program implement a class name vector that provides the vectorfunctionality needed by the test code in Vector_test.cpp.100% done.*******************************************************************************/#ifndef VECTOR_H#define VECTOR_H#include <iostream>using namespace std;template<class T>class Vector{private:    unsigned int my_size;    unsigned int my_capacity;    T * buffer;    public:    typedef T * iterator;    Vector();    Vector(unsigned int size);    Vector(unsigned int size, const T & initial);    Vector(const Vector<T> & v);        // copy constructor    ~Vector();    unsigned int capacity() const;      // return capacity of vector (in elements)    unsigned int size() const;          // return the number of elements in the vector    bool empty() const;        iterator begin();                   //return an iterator pointing to the first elements    iterator end();                     //return an iterator pointing to one past the last element    T & front();                        //return a reference to the first element    T & back();                         //return a reference to the last element    void push_back(const T & value);    //add a new element    void pop_back();                    //remove the laset element    void reserve(unsigned int capacity);    //adjust capacity    void resize(unsigned int size);         //adjust size    T & operator[] (unsigned int index);    //return reference to numbered element    Vector<T> & operator=(const Vector<T> &);};template <class T>Vector<T>::Vector(){    my_size = 0;    my_capacity = 0;    buffer = 0;}template <class T>Vector<T>:: Vector(unsigned int size){    my_size = size;    my_capacity = size;    buffer = new T[size];        for(int i=0;i<size;i++)        buffer[i]= T();                 //set buffer to whatever type T is.}template <class T>Vector<T>:: Vector(unsigned int size, const T& initial){    my_size = size;    my_capacity = size;    buffer = new T[size];    for(int i=0; i<size; i++)        buffer[i] = initial;} // time complexity O(n)template <class T>Vector<T>:: Vector(const Vector<T> & v)     //copy constructor{    my_size = v.my_size;    my_capacity = v.my_size;    buffer = new T[my_size];    for(int i=0; i<my_size; i++)        buffer[i] = v.buffer[i];} //time complexity O(n)template <class T>Vector<T>:: ~Vector(){    delete [] buffer;}template<class T>unsigned int Vector<T>::capacity() const{    return my_capacity;}template<class T>unsigned int Vector<T>::size() const{    return my_size;}template<class T>bool Vector<T>:: empty() const{    if(my_size == 0)        return true;    else        return false;} // time complexity O(n)template<class T>typename Vector<T>::iterator Vector<T>::begin(){    return buffer;}template<class T>typename Vector<T>::iterator Vector<T>::end(){    return buffer + size();}template<class T>void Vector<T>:: push_back(const T & value){    if(my_size == my_capacity) {        reserve(my_size + 5);    }    buffer[my_size++] = value;}   // time complexity O(n)template<class T>void Vector<T>:: pop_back(){    my_size--;}template<class T>void Vector<T>:: reserve(unsigned int capacity)     //adjust capacity{    if(capacity <= my_capacity)        return;        my_capacity = capacity;    T * new_buffer = new T[capacity];    for(int size=0; size<my_size; size++)    {        new_buffer[size] = buffer[size];    }        delete [] buffer;    buffer = new_buffer;} // time complexity O(n)template<class T>void Vector<T>:: resize(unsigned int size)      //adjust size{    reserve(size);    my_size = size;}template<class T>T& Vector<T>::operator[] (unsigned int index){    return buffer[index];}template<class T>Vector<T> & Vector<T>:: operator=(const Vector<T> & v){    delete[] buffer;    my_size = v.size;    my_capacity = v.capacity;    buffer = new T[my_size];    for (int i=0; i < my_size; i++) {        buffer[i] = v.buffer[i];    }    return * this;} // time complexity 0(n)#endif