/*Jerome Hayes JrDeque.h2/24/16In this program I remade the Data Structure Deque, that is normaly found in the STL.100 % done*/#ifndef DEQUE_H#define DEQUE_H#include <vector>using namespace std;template <class T> class DequeIterator;template <class T>class Deque {public:    typedef DequeIterator<T> iterator;    Deque(): vecOne(), vecTwo() {}    Deque(const unsigned int size, const T& initial): vecOne(size/2, initial), vecTwo(size-(size/2), initial) {}    ~Deque() {}    Deque & operator = (const Deque<T> & d);    T & operator[] (unsigned int);     T & front();        T & back();        bool empty() {return vecOne.empty() && vecTwo.empty();}        iterator begin() { return iterator(this, 0);}               iterator end() {return iterator(this, size());}            void erase(const iterator &);       void erase(const iterator &, const iterator &);          void insert(const iterator &, const T &);    int size() {return vecOne.size() + vecTwo.size();}          void push_front(const T & value) {vecOne.push_back(value);}         void push_back(const T & value) {vecTwo.push_back(value);}          void pop_front();      void pop_back();    protected:    vector<T> vecOne;    vector<T> vecTwo;};template <class T>Deque<T> & Deque<T>::operator=(const Deque<T> & d){    vecOne = d.vecOne;    vecTwo = d.vecTwo;    return * this;}//O(n)template <class T>T & Deque<T>::operator[] (unsigned int index){    int n = vecOne.size();    if(index < n)        return vecOne[(n-1)-index];    else        return vecTwo[index-n];}//0(1)template <class T>T & Deque<T>::front(){    if(!vecOne.empty())        return vecOne.back();    else        return vecTwo.front();}//O(1)template <class T>T & Deque<T>::back(){    if(!vecTwo.empty())        return vecTwo.back();    else        return vecOne.front();}//O(1)template <class T>void Deque<T>::pop_front(){    if(vecOne.empty())        vecTwo.erase(vecTwo.begin());    else        vecOne.pop_back();}//O(1)template <class T>void Deque<T>::pop_back(){    if(vecTwo.empty())        vecOne.erase(vecOne.begin());    else        vecTwo.pop_back();}//O(1)template<class T>void Deque<T>::erase(const iterator &itr){    int index = itr.index;    int n = vecOne.size();    if (index < n)        vecOne.erase(vecOne.begin() + ((n-1) - index));    else        vecTwo.erase(vecTwo.begin() + (index -n));}//O(n)template<class T>void Deque<T>::erase(const iterator &a, const iterator &b){    int index = a.index;    int n = vecOne.size();    int s = b.index;    for (; index < s; index++) {        if(index < n)            vecOne.erase(vecOne.begin() + ((n-1) - index));        else            vecTwo.erase(vecTwo.begin() + (index -n));    }}//O(n)template<class T>void Deque<T>::insert(const iterator &i, const T& value){    int index = i.index;    int n = vecOne.size();    if (index < n)        vecOne.insert(vecOne.begin() + ((n)-index), value);    else        vecTwo.insert(vecTwo.begin() + (index-n), value);}//O(n)template <class T>class DequeIterator {    friend class Deque<T>;    typedef DequeIterator<T> iterator;public:    DequeIterator(): theDeque(0), index(0) {}    DequeIterator(Deque <T> * d, int i): theDeque(d), index(i) {}    DequeIterator(const iterator & d): theDeque(d.theDeque), index(d.index) {}    T & operator* () {return (*theDeque)[index];}    iterator & operator++();    iterator operator++(int){++index; return *this;}    iterator & operator--();    iterator operator--(int) {--index; return * this;}    bool operator==(const iterator & r) {return theDeque==r.theDeque && index==r.index;}    bool operator!=(const iterator & r) {return theDeque != r.theDeque;}    bool operator<(const iterator & r)  {return theDeque==r.theDeque && index < r.index;}    T & operator[](unsigned int i) {return (*theDeque) [index+i];}    iterator operator=(const iterator & r) {theDeque = r.theDeque; index = r.index; return iterator(theDeque, index);}    iterator operator+(int i) {return iterator(theDeque, index + i);}    iterator operator-(int i) {return iterator(theDeque, index - i);}protected:    Deque<T> * theDeque;    int index;};template<class T>typename DequeIterator<T>::iterator & DequeIterator<T>::operator++(){    DequeIterator copy(theDeque,index);    index++;    return *this;}template<class T>typename DequeIterator<T>::iterator &DequeIterator<T>::operator--(){    DequeIterator copy(theDeque, index);    index--;    return *this;}#endif