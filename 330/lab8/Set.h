/*Jerome Hayes JrSet.h3/2/16This program I recreated the Data Structure of Set,which is normally found in STL.This program is my implementation.*/#ifndef SET_H#define SET_H#include <iostream>using namespace std;template <class T> class Set;template <class T> class Set_iterator;template <class T>class Node {public:    Node(): value(0), parent(0), leftChild(0), rightChild(0) {}    Node(const T &x, Node * p, Node * lc, Node *rc):        value(x), parent(p), leftChild(lc), rightChild(rc) {}        Node(const Node & n): value(n.value), parent(0), leftChild(0), rightChild(0) {}    Node & operator=(const Node & n) { value = n.value; return *this;}    ~Node() {delete leftChild; delete rightChild;}    void insert(Node<T> * newNode);     //this is a helper func for Set::insert()    Node * find(const T & x);    Node * merge(Node<T> * left, Node<T> * right);    void inorder_count(const Node<T> *pos, const T&x, int &count);protected:    T value;    Node * parent;    Node * leftChild;    Node * rightChild;friend class Set<T>;friend class Set_iterator<T>;};//Node/* The insertion routine for class node simply walks down the tree until the leaf position is found, then places the new node into location.*/template<class T>void Node<T>::insert(Node<T> * newNode){    if(newNode -> value <= value)        if (leftChild != 0)            leftChild ->insert(newNode);        else {            newNode -> parent = this;            leftChild = newNode;        }    else        if(rightChild != 0)            rightChild -> insert(newNode);        else {            newNode -> parent = this;            rightChild = newNode;        }} // O(log n)template<class T>Node<T> * Node<T>:: merge(Node<T> * left, Node<T> * right){    if(left == 0)        return right;    if(right == 0)        return left;        Node<T> *child = merge(left, right -> leftChild);    child -> parent = right;    right -> leftChild = child;    return right;}template<class T>Node<T> * Node<T>::find(const T & x){    if(x == this->value)        return this;    if(x < this->value){        if(leftChild == 0)            return 0;        return leftChild -> find(x);    }    if (rightChild == 0)        return 0;    return rightChild -> find(x);}template<class T>void Node<T>::inorder_count(const Node<T> *pos, const T &x, int & count){    if(pos){        inorder_count(pos->leftChild, x, count);        if(pos -> value == x)            count++;        inorder_count(pos->rightChild, x, count);    }} //O(log n)template <class T>class Set {public:    typedef Set_iterator<T> iterator;        Set(): root(0), my_size(0) {}    //the big three    Set(const Set<T> & );   //done    ~Set() {delete root; }    Set operator=(const Set &);    bool empty() const { return root == 0;}    unsigned int size() const {return my_size;}    iterator insert(const T & x);   //return an iterator to x if it already exists otherwise insert and return an iterator to x    void erase(const iterator & it);    void erase(const T & x) {root = remove(root, x);}    unsigned int count(const T & x) const;      //returns 1 or 0 because this is a set, not a multi-set    iterator find(const T & x) const {return root -> find(x);}    iterator begin() const;     // for in-order traversal    iterator end() const {return iterator(0);}protected:    Node<T> * root;    unsigned int my_size;    Node<T> * remove(Node<T> *, const T &);};//Settemplate<class T>Set<T>::Set(const Set<T> & op){    root = 0;    for (iterator i = op.begin(); i != op.end(); i++)            insert(*i);}template <class T>Set<T> Set<T>::operator=(const Set<T> & op){    delete root;    root = 0;    for(iterator i = op.begin(); i != op.end(); ++i)        insert(*i);    return *this;}template<class T>typename Set<T>::iterator Set<T>::insert(const T &x){    if (count(x) > 0)        return find(x);    Node<T> *newNode = new Node<T> (x,0,0,0);    if (root == 0)        root = newNode;    else        root -> insert(newNode);    my_size++;    return iterator(newNode);} //O(log n)template<class T>void Set<T>:: erase(const iterator & it){    if (root != 0  and it != end()) {        Node<T> *p = it.n;        if (p != 0) {            Node<T> *left = p->leftChild;            Node<T> *right = p -> rightChild;            Node<T> *left_slide = right;            if (right != 0) {                while (left_slide -> leftChild)                    left_slide = left_slide -> leftChild;                left_slide -> leftChild = left;                if (left !=  0)                    left -> parent = left_slide;                right -> parent = p -> parent;                if (p -> parent)                    if (p -> parent -> leftChild == p)                        p -> parent -> leftChild = right;                    else p->parent->rightChild = right;                else                    root = right;            } else {                if (left == 0){                    if (p -> parent)                        if (p -> parent -> leftChild == p)                            p -> parent -> leftChild = 0;                        else p -> parent -> rightChild = 0;                    else                        root = 0;                } else {                    left -> parent = p -> parent;                    if (p -> parent){                        if (p -> parent){                            if (p -> parent -> leftChild == p)                                p -> parent -> leftChild = left;                            else{ p-> parent -> rightChild = left; }                        }                        else                            root = left;                    }                }                            }            p -> leftChild = 0;            p -> rightChild = 0;            delete p;            my_size--;        }    }} //O(log n)template<class T>unsigned int Set<T>::count(const T &x) const{    int count = 0;    root -> inorder_count(root,x,count);    return count;}template<class T>typename Set<T>::iterator Set<T>::begin() const{    Node<T> * current = root;    while (current && current -> leftChild)        current = current -> leftChild;    return iterator(current);} //O(log n)template<class T>Node<T> * Set<T>::remove(Node<T> * current, const T & testElement){    if (current != 0) {        Node<T> * pa = current->parent;        if(testElement < current->value)            current->leftChild = remove(current->leftChild, testElement);        else if (current -> value < testElement)            current ->rightChild = remove(current->rightChild, testElement);        else {            Node<T> * result = current->merge(remove(current->leftChild, testElement),                    current->rightChild);            current->leftChild = 0;            current->rightChild = 0;            delete current;            my_size--;            if(result)                result->parent = pa;            return result;        }    }    return current;} //O(log n)template<class T>class Set_iterator {public:    Set_iterator(): n(0) {}    Set_iterator(Node<T> * newNode): n(newNode) {}    bool operator==(Set_iterator it) const {return n == it.n;}    bool operator!=(Set_iterator it) const {return n != it.n;}    Set_iterator & operator++();    //inorder traversal, pre-increment    Set_iterator operator++(int);   //inoder trfaversal, post-increment    T & operator*() {return n-> value;}    Set_iterator & operator=(Set_iterator<T> it) {n = it.n; return *this; }protected:    Node<T> * n;friend class Set<T>;};//Set_iteratortemplate<class T>Set_iterator<T> & Set_iterator<T>::operator++(){    if (n->rightChild){        n = n -> rightChild;        while(n->leftChild)            n = n -> leftChild;    }    else{        Node<T> * child = n;        n = n->parent;        while(n && n -> rightChild == child){            child = n;            n = n -> parent;        }    }    return *this;} //O(log n)template<class T>Set_iterator<T> Set_iterator<T>::operator++(int) {    Set_iterator<T> clone(n);    operator++();    return clone;} //O(log n)#endif