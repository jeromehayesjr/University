/*Jerome Hayes JrPriority_Queue.h3/10/16This Program recreates Priority Queue functions that are normally found in STL.100% donetime complex O(log n)*/#ifndef PRIORITY_QUEUE_H#define PRIORITY_QUEUE_H#include <vector>using namespace std;template <class T>class Priority_queue {public:    Priority_queue() : c() {}    Priority_queue(const Priority_queue & p): c(p.c) {}    Priority_queue & operator=(const Priority_queue & p) {c= p.c; return *this;}        bool empty() {return c.empty();}    unsigned int size() {return c.size();}    void push(const T & x);    void pop();    T & top() {return c.front();}private:    vector<T> c;};template <class T>void Priority_queue<T>::push(const T & x){    c.push_back(x);    unsigned int position = (c.end() - c.begin()) -1;    unsigned int parent = (position - 1) /2;    while (position > 0 and c[position] > c[parent]) {        swap(c[position], c[parent]);        position = parent;        parent = (position -1)/2;    }}template <class T>void Priority_queue<T>::pop(){    unsigned int lastPosition = (c.end() - c.begin()) -1;    swap(c[0], c[lastPosition]);    unsigned int position = 0;    unsigned int heapSize = c.size() -1;    unsigned int childPos = position * 2 + 1;    while(childPos < heapSize) {        if((childPos + 1 < heapSize) and c[childPos +1] > c[childPos])            childPos++;        if(c[position] > c[childPos])            break;        else            swap(c[position], c[childPos]);    }    position = childPos;    c.pop_back();}#endif